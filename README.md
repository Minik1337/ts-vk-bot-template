# Typescript шаблон для создания ботов ВКонтакте
Простенький шаблон для создания ботов Вконтакте основанный на модуле [vk-io](https://github.com/negezor/vk-io/)

# Установка
Перед тем как использовать данный шаблон, необходимо установить сам typscript.

```
npm install typescript -g
```

После его установки необходимо склонировать этот репозиторий к себе локально

```
git clone https://github.com/MiniK1337/ts-vk-bot-template
```

Теперь переходим в папку, куда склонировали репозиторий и устанавливаем все необходимые зависимости.

```
npm install
```

### Файл конфигурации
После клонирования репозитория и установок зависимостей, в папке с репозиторием создаем файл config.json и заполняем его:

```js
{
    "vk": {
        "token": "TOKEN", // Сюда вставляем ваш токен (можно использовать как токен юзера, так и группы)
        "group_id": null // Сюда прописываем id вашей группы (если токен юзера - оставляем значение null)
    }
}
```

### Компиляция и запуск
В той же папке в репозиторием прописываем:

```
npm start
```

Если всё запустилось и работает, в консоле должно написать "Started!"

# Использование
Данная имплементация работает на модулях, в папке /src/modules содержаться все модули которые будет подгружать бот.
Каждый модуль предсталвяет собой отдельный класс, в котором происходит инициализация доступных ему команд. Это очень удобно, в том плане, что можно создавать отдельный блоки команд, которые никак не будут пересекаться с остальными, а значит и не будет никаких внутренних конфликтов.

Для примера возьмем стартовый, доступный после клонирования, модуль Test из данного репозитория:
```ts
import { Module } from "../../Module";
import { Bot } from "../../Bot";

import {
    TestCommand
} from "./commands";

class Test extends Module {
    bot: Bot;
    constructor(bot: Bot) {
        super(bot);

        this.bot = bot;

        this.initCommands([
            new TestCommand(this)
        ]);
    }
}

export {
    Test
}
```

Как уже говорил ранее, каждый модуль представляет собой инициализацию команд, из каждой такой команды можно обратно получить доступ к модулю, что позволяет делать общий функционал для опредленных наборов команд.

Теперь разберем сами команды, они находятся в папке /{module_name}/commands, в пример возьмем одну их них - TestCommand, которая уже имеется в нашем модуле.

```ts
import { Command } from "../../../Command";
import { Module } from "../../../Module";

export class TestCommand extends Command {
    constructor(module: Module) {
        super(module);

        this.setHearCondition(/(!|\.|\/)?ping/i);
        
        this.setCallback(context => {
            context.send('pong');
        });
    }
}
```
Как можно увидеть, для каждой команды существует условие для её вызова и сама callback функция команды.
В данном примере, прослушкой выступает регулярное выражение, а callback фукнция вызывает метод send, который отправлеят сообщение.

Теперь если написать нашему боту: !ping .ping /ping ping - он ответит pong

![Пример работы команды](https://sun9-20.userapi.com/c206824/v206824015/11121e/UrTei9sARcM.jpg)

Немного пройдемся по методам, которые используются при создании команды

### setHearCondtition
Устанавливает условие для прослушки данной команды. Может быть как callback функцией, так и регулярным выражением.

```ts
setHearCondition(hearCondition: ((context: MessageContext) => boolean) | RegExp)
```

### setCallback
Устанавливает callback функцию, которая будет вызываться каждый раз, когда будет срабатывать условие для прослушки.

```ts
setCallback(callback: (context: MessageContext) => void)
```

# Заключение
По итогу мы получаем очень удобную обертку над vk-io. Вот и сказочке конец, а кто читал тот молодец :D
